# 如何在本框架内实现板级/片级逻辑与设备逻辑的分离

## 整体思路
板级/片级逻辑体现在：开发板引出了哪些单片机支持的外设，对这些外设功能，参数的具体配置。

设备逻辑体现为：框架内使用的设备，如电机，传感器。设备一般需要使用一个或多个外设。

为了实现板级/片级逻辑与设备逻辑的分离，考虑将常用的外设抽象成外设类。
外设类中以宏定义方式调用HAL库的处理句柄，因此实现了对设备号的抽象。
外设类统一管理外设的调用方式，设备类只需要调用简单接口，因此屏蔽了外设的中断，定时执行等复杂逻辑。

## 外设-模块-组件依赖链

由于框架同时支持多个BSP包，当无法提供外设类需要的HAL库处理句柄时将无法通过编译。因此考虑利用条件编译实现一个依赖链，即模块(外设类)先检查自身所需的外设依赖是否被当前的BSP包实现，若全部实现则加入编译。
类似地，组件指的是实际机器人中各个部分对应的具体代码，需要检查其需要的模块依赖是否全部满足，而后加入编译。

这样，在切换BSP包时，可以在只配置一部分外设的情况下使用框架。也可以手动关闭框架的不同组件，提高了框架的可剪裁性。

具体的配置文件参见 Interface/ProjectConifg.h
以及BSP包中与包名同名的头文件

## 具体操作参考
### 首先针对模块(外设类)的头文件和源文件添加启用/关闭模块的处理：
在头文件中，clion自动生成的用于防止多次调用头文件的宏定义检查之后：
首先包括系统配置文件ProjectConfig.h
然后将剩余的全部内容添加进#ifdef结构，检查的宏定义为模块名全部大写,并在后面添加_MODULE
```
#ifndef FINEMOTE_I2C_BASE_H  
#define FINEMOTE_I2C_BASE_H  
  
#include "ProjectConfig.h"  
  
	#ifdef I2C_BASE_MODULE
		//具体内容
	#endif  
#endif //FINEMOTE_I2C_BASE_H
```

在源文件中，首先包括对应的头文件，然后添加#ifdef结构

```
#include "I2C_Base.h"  
#ifdef I2C_BASE_MODULE
	//具体内容
#endif	
```
### 在ProjectConfig.h中检查外设依赖
处理各模块对BSP包的依赖关系，若满足全部依赖则启用模块，此处需要以doxygen风格注释形式给出应由BSP包实现的依赖条件的具体内容  
以@def 标记需要的宏定义，@variable 标记需要定义的变量，实现依赖条件后可由BSP包定义依赖条件对应宏定义  
各模块的部分配置选项也可以宏定义的方式提供于此处
```
/**  
 * I2C_PERIPHERAL 模块所需的I2C外设依赖条件  
 * @def USER_I2C 配置的I2C外设  
 */
#if defined(I2C_PERIPHERAL) 
	#define I2C_BASE_MODULE  
	#define AGNET_TASK_MAX_NUM 200  
#endif
```
使用#if  defined() 可以实现依赖条件的逻辑运算，#ifdef只能检查一项宏定义。

### 在BSP包中实现外设依赖
通过对cube配置生成文件，实现外设依赖

> 框架统一使用cube6.8.1，如果使用了更高版本覆盖将导致其他人无法修改项目

> 上传代码时，BSP包的部分应该与模块部分分开上传

按照ProjectConfig.h的要求给出宏定义或其他所需条件

```
#define USER_I2C hi2c2  
#define I2C_PERIPHERAL
```

**注意**：在使用cube生成代码后，需要保持BSP包头文件中HALInit类的构造函数与cube生成的main函数中，被跳过的初始化操作一致。

HALInit是一个单例模式，其作用是保证在其他类的对象被构造时，HAL库的初始化已经完成。具体的操作方式是，在需要使用HAL库函数的类的构造函数中调用
```
HALInit::GetInstance();
```
以保证HALInit类的单例对象被构建，即HAL库的初始化以完成。同时为了防止main函数中初始化函数的再次调用会重置外设配置，在cube不会覆盖的USER CODE区域使用goto语句跳过了main函数中的初始化函数。